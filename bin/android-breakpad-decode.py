#!/usr/bin/env python

# android-breakpad-decode

# Produces a decoded backtrace from a minidump file, generated by BreakPad.
# http://code.google.com/p/google-breakpad/w/list

# The script does the following:
# 1. Run minidump_stackwalk on the .dmp file
# 2. From the minidump_stackwalk output, extract a list of the libraries
#    for which symbols are required
# 3. Scan $ANDROID_PRODUCT_OUT/symbols for the required libraries; for each one
#    found, run dump_syms and write the output to
#    $ANDROID_PRODUCT_OUT/symbols/minidump
# 4. Run minidump_stackwalk again to generate the decoded stack trace

# For some reason which is not currently understood, minidump sometimes fails
# to determine the version of the libraries.  This means that it looks for
# symbol files in <sym_dir>/foo.so/0000000000000000000000/foo.so.sym.  If this
# is the case, set environment variable
# ANDROID_BREAKPAD_DECODE_BROKEN_VERSION=1 before running the script.  This
# causes the script to discard any existing symbol files and regenerate them
# all, to avoid using an out-of-date symbol file (which would not be detected
# due to the all-zero version hash) when decoding the stack dump.

#------------------------------------------------------------------------------
# Imports
#------------------------------------------------------------------------------

import argparse
import logging
import os
import shutil
import subprocess
import sys
import tempfile
from time import time


#------------------------------------------------------------------------------
# Global constants
#------------------------------------------------------------------------------

LINE_WIDTH = 80

BROKEN_VERSION = False
if 'ANDROID_BREAKPAD_DECODE_BROKEN_VERSION' in os.environ.keys():
    if os.environ['ANDROID_BREAKPAD_DECODE_BROKEN_VERSION'] != '':
        BROKEN_VERSION = True


#------------------------------------------------------------------------------
# Classes
#------------------------------------------------------------------------------

class ArgumentParser(argparse.ArgumentParser):
    def __init__(self):
        description = 'Android BreakPad decoder'
        epilog = '''
        Script for decoding crash dumps generated by Android apps using the
        Google BreakPad tool
        '''
        version = '0.1'

        argparse.ArgumentParser.__init__(self,
                                         description = description,
                                         epilog = epilog)

        # Positional arguments
        self.add_argument('dump',
                          metavar='DUMP',
                          help='Dump file')

        # Options
        self.add_argument('-o', '--out',
                          dest='out_dir', default=None,
                          help='output directory')
        self.add_argument('--debug',
                          dest='debug', default=False,
                          action='store_true',
                          help='show debugging output')
        self.add_argument('-f', '--force',
                          dest='force', default=False,
                          action='store_true',
                          help='overwrite existing output files')
        self.add_argument('-n', '--dry-run',
                          dest='dry_run', default=False,
                          action='store_true',
                          help='just show what would be done')
        self.add_argument('-v', '--verbose',
                          dest='verbose', default=False,
                          action='store_true',
                          help='produce verbose output')
        self.add_argument('-V', '--version',
                          dest='version',
                          action='version',
                          version=version,
                          help="show program's version number and exit")


# Progress bar
# Based on code from http://stackoverflow.com/questions/274493/how-to-copy-a-file-in-python-with-a-progress-bar

class ProgressBar:
    def __init__(self, minValue = 0, maxValue = 10, totalWidth = 40):
        self.min = minValue
        self.max = maxValue
        self.span = maxValue - minValue
        self.width = totalWidth
        self.amount = 0
        self.percentDone = 0
        self.elapsedSecs = 0
        self.startTime = time()
        self.note = ''
        self.maxWidth = 0
        self.update(0) # Build progress bar string

    def update(self, note = None, amount = -1):
        self.note = note if note else ''

        if amount != -1:
            if amount < self.min: amount = self.min
            if amount > self.max: amount = self.max
            self.amount = amount

        # Figure out the new percent done, round to an integer
        diffFromMin = float(self.amount - self.min)
        percentDone = (diffFromMin / float(self.span)) * 100.0
        percentDone = round(percentDone)
        percentDone = int(percentDone)

        # Calculate elapsed time
        secs = int(time() - self.startTime)

        # Decide whether to update the display
        if 100 == self.percentDone:
            return
        if (0 == self.amount) or (percentDone - self.percentDone >= 1) \
            or (secs - self.elapsedSecs >= 1) or (100 == percentDone):
            self.percentDone = percentDone
            self.elapsedSecs = secs
        else:
            return

        # Figure out how many hash bars the percentage should be
        allFull = self.width - 2
        numHashes = (percentDone / 100.0) * allFull
        numHashes = int(round(numHashes))

        # Build progress bar
        output = "[" + '#'*numHashes + ' '*(allFull-numHashes) + "]"

        # Append percentage
        output += ' %3d%%' % percentDone

        # Calculate elapsed time
        mins = 0
        hours = 0
        if secs >= 60 * 60:
            hours = int(secs / (60 * 60))
            secs -= hours * (60 * 60)
        if secs >= 60:
            mins = int(secs / 60)
            secs -= mins * 60
        #output += ' %02d:%02d:%02d' % (hours,mins,secs) #hours, mins, secs)

        output += ' ' + self.note
        self.maxWidth = max(len(output), self.maxWidth)
        output += ' ' * (self.maxWidth - len(output))

        # Write to display
        sys.stdout.write('\r%s\r' % output)

        if 100 == percentDone:
            sys.stdout.write('\n')


class SubprocessOutput(object):
    def __init__(self):
        self.out = ''
        self.err = ''


class MinidumpStackwalk(object):
    def __init__(self, dump, config):
        self._dump = dump
        self._config = config

    def run(self):
        args = ['minidump_stackwalk', self._dump]
        sym_dir = self._config['sym_dir']
        if os.path.exists(sym_dir):
            args.append(sym_dir)
        p = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        result = SubprocessOutput()
        result.out, result.err = p.communicate()
        return result

    def get_libs(self):
        result = []
        output = self.run().out.split('\n')
        in_section = False
        for line in output:
            if in_section:
                tokens = line.split()
                if len(tokens) > 3:
                    lib = tokens[3]
                    if lib.endswith('.so'):
                        result.append(Library(lib))
                else:
                    in_section = False
            if line.startswith('Loaded modules:'):
                in_section = True
        return result


class Library(object):
    '''
    Represents an .so file
    '''
    def __init__(self, name):
        self.name = name
        self.path = None
        self.sym_name = None
        self.sym_hash = None
        self.sym_path = None

    def __repr__(self):
        result = self.name
        if self.path:
            result += '(' + self.path + ')'
        return result


#------------------------------------------------------------------------------
# Utility functions
#------------------------------------------------------------------------------

def print_error(message):
    print >> sys.stderr, 'Error:', message


def parse_command_line():
    '''
    Return: argparse.Namespace
    '''
    parser = ArgumentParser()
    return parser.parse_args()


def print_summary(args, *initial_group):
    '''
    Print results of parsing command line
    Second argument indicates which values should be displayed at the top of
    the list.  These should typically be the destination variables for the
    positional parameters.
    '''
    keys = [name for name in dir(args) if not name.startswith('_')]
    maxkeylen = max([len(key) for key in keys])
    maxvaluelen = max([len(str(getattr(args, key))) for key in keys])
    rightcolpos = LINE_WIDTH - maxvaluelen - 2
    print '-' * LINE_WIDTH
    print 'Summary of options'
    print '-' * LINE_WIDTH
    for key in initial_group:
        print ' '+ key, ('.' * (rightcolpos - len(key) - 2)), getattr(args, key)
    for key in sorted(list(set(keys) - set(initial_group))):
        print ' '+ key, ('.' * (rightcolpos - len(key) - 2)), getattr(args, key)
    print '-' * LINE_WIDTH


def file_exists(filename):
    result = True
    try:
        with open(filename) as f: pass
    except IOError as e:
        result = False
    return result


def build_lib_dict(lib_dir, args):
    result = { }
    for root, dirs, files in os.walk(lib_dir):
        for name in files:
            if name.endswith('.so'):
                path = os.path.join(root, name)
                logging.debug('build_lib_dict ' + name + ' ' + path)
                result[name] = path
    return result


def resolve_libs(libs, args, config):
    print "\nResolving libraries ..."
    lib_dir = config['lib_dir']
    lib_dict = build_lib_dict(lib_dir, args)
    for lib in libs:
        if lib.name in lib_dict.keys():
            lib.path = lib_dict[lib.name]
        else:
            print >> sys.stderr,'Warning: failed to resolve ' + lib.name


def generate_symbols(lib, args, config):
    sym_dir = config['sym_dir']
    logging.debug("generate_symbols so_path " + lib.path)
    p = subprocess.Popen(['dump_syms', lib.path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    result = SubprocessOutput()
    result.out, result.err = p.communicate()
    err = open(config['err_file'], 'a')
    write_banner(err, 'dump_syms ' + lib.path)
    if result.out.startswith('MODULE'):
        lines = result.out.split('\n')
        tokens = lines[0].split()
        sym_name = tokens[4]
        logging.debug("generate_symbols sym_name " + sym_name)
        if sym_name == lib.name:
            lib.sym_name = sym_name
            lib.sym_hash = tokens[3]

            if BROKEN_VERSION:
                lib.sym_hash = '000000000000000000000000000000000'

            logging.debug("generate_symbols sym_hash " + lib.sym_hash)
            lib.sym_path = os.path.join(sym_dir, lib.sym_name, lib.sym_hash, lib.sym_name + '.sym')
            logging.debug("generate_symbols sym_path " + lib.sym_path)
            if not os.path.exists(lib.sym_path):
                os.makedirs(os.path.dirname(lib.sym_path))
                sym_file = open(lib.sym_path, 'w')
                sym_file.write(result.out)
        else:
            print >> sys.stderr,'Warning: symbol name mismatch ({0:s}, {1:s}'.format(lib.name, sym_name)


def generate_all_symbols(libs, args, config):
    print "\nGenerating symbols ..."
    p = ProgressBar(maxValue = len(libs))
    n = 0
    for lib in libs:
        p.update(note = lib.name)
        if lib.path:
            generate_symbols(lib, args, config)
        n += 1
        p.update(note = lib.name, amount = n)
    print


def print_libs(libs):
    print "Summary of libraries listed in minidump file:"
    print '----------------------------------------------------------------'
    print 'name                              resolved  symbols'
    print '----------------------------------------------------------------'
    for lib in libs:
        has_path = 'y' if lib.path else 'n'
        sym_hash = lib.sym_hash[0:6] if lib.sym_hash else '-'
        print '{0:40s} {1:s}   {2:s}'.format(lib.name, has_path, sym_hash)
    print '----------------------------------------------------------------'


def write_banner(fh, msg):
    fh.write('\n\n\n')
    fh.write('---------------------------------------------------------\n')
    fh.write(msg + '\n')
    fh.write('---------------------------------------------------------\n')


def check_output(filename, args):
    if os.path.exists(filename):
        if args.force:
            os.remove(filename)
        else:
            raise IOError, "Output file '" + filename + "' already exists"


def write_output(stackwalk, args, config):
    print "\nWriting output to " + config['stk_file'] + ' ...'
    out = open(config['stk_file'], 'w')
    err = open(config['err_file'], 'a')
    result = stackwalk.run()
    out.write(result.out)
    write_banner(err, 'minidump_stackwalk')
    err.write(result.err)


#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

args = parse_command_line()

if args.verbose:
    print_summary(args, ('dump'))
if args.debug:
    logging.getLogger().setLevel(logging.DEBUG)

if os.environ['ANDROID_PRODUCT_OUT'] == '':
    raise IOError, "ANDROID_PRODUCT_OUT is not set - have you lunched?"

# Compose default output directory path
if not args.out_dir:
    dmp_dir, dmp_name = os.path.split(args.dump)
    dmp_desc, dmp_ext = os.path.splitext(dmp_name)
    args.out_dir = os.path.join(dmp_dir, dmp_desc + '_decoded')

config = {
    'lib_dir': os.path.join(os.environ['ANDROID_PRODUCT_OUT'], 'symbols'),
    'sym_dir': os.path.join(os.environ['ANDROID_PRODUCT_OUT'], 'symbols', 'minidump'),
    'stk_file': os.path.join(args.out_dir, 'breakpad.stk'),
    'err_file': os.path.join(args.out_dir, 'breakpad.err')
}

# If library versioning is broken, then we clean out the symbols in case any
# library has been rebuilt since they were generated
if os.path.exists(config['sym_dir']) and BROKEN_VERSION:
    print "ANDROID_BREAKPAD_DECODE_BROKEN_VERSION is set"
    print "\nRemoving old symbols ..."
    shutil.rmtree(config['sym_dir'])

# Ensure output directory exists, and check whether output files exist
if not os.path.exists(args.out_dir):
    os.makedirs(args.out_dir)
check_output(config['stk_file'], args)
check_output(config['err_file'], args)

# The guts
stackwalk = MinidumpStackwalk(args.dump, config)
libs = stackwalk.get_libs()
resolve_libs(libs, args, config)
generate_all_symbols(libs, args, config)
print_libs(libs)
write_output(stackwalk, args, config)

