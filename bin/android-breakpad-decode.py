#!/usr/bin/env python

# android-breakpad-decode

#------------------------------------------------------------------------------
# Imports
#------------------------------------------------------------------------------

import argparse
import logging
import os
import subprocess
import sys
import tempfile
from time import time


#------------------------------------------------------------------------------
# Global constants
#------------------------------------------------------------------------------

LINE_WIDTH = 80


#------------------------------------------------------------------------------
# Classes
#------------------------------------------------------------------------------

class ArgumentParser(argparse.ArgumentParser):
    def __init__(self):
        description = 'Android BreakPad decoder'
        epilog = '''
        Script for decoding crash dumps generated by Android apps using the
        Google BreakPad tool
        '''
        version = '0.1'

        argparse.ArgumentParser.__init__(self,
                                         description = description,
                                         epilog = epilog)

        # Positional arguments
        self.add_argument('dump',
                          metavar='DUMP',
                          help='Dump file')

        # Options
        self.add_argument('--debug',
                          dest='debug', default=False,
                          action='store_true',
                          help='show debugging output')
        self.add_argument('-n', '--dry-run',
                          dest='dry_run', default=False,
                          action='store_true',
                          help='just show what would be done')
        self.add_argument('-v', '--verbose',
                          dest='verbose', default=False,
                          action='store_true',
                          help='produce verbose output')
        self.add_argument('-V', '--version',
                          dest='version',
                          action='version',
                          version=version,
                          help="show program's version number and exit")


# Progress bar
# Based on code from http://stackoverflow.com/questions/274493/how-to-copy-a-file-in-python-with-a-progress-bar

class ProgressBar:
    def __init__(self, minValue = 0, maxValue = 10, totalWidth = 40):
        self.min = minValue
        self.max = maxValue
        self.span = maxValue - minValue
        self.width = totalWidth
        self.amount = 0
        self.percentDone = 0
        self.elapsedSecs = 0
        self.startTime = time()
        self.note = ''
        self.maxWidth = 0
        self.update(0) # Build progress bar string

    def update(self, note = None, amount = -1):
        self.note = note if note else ''

        if amount != -1:
            if amount < self.min: amount = self.min
            if amount > self.max: amount = self.max
            self.amount = amount

        # Figure out the new percent done, round to an integer
        diffFromMin = float(self.amount - self.min)
        percentDone = (diffFromMin / float(self.span)) * 100.0
        percentDone = round(percentDone)
        percentDone = int(percentDone)

        # Calculate elapsed time
        secs = int(time() - self.startTime)

        # Decide whether to update the display
        if 100 == self.percentDone:
            return
        if (0 == self.amount) or (percentDone - self.percentDone >= 1) \
            or (secs - self.elapsedSecs >= 1) or (100 == percentDone):
            self.percentDone = percentDone
            self.elapsedSecs = secs
        else:
            return

        # Figure out how many hash bars the percentage should be
        allFull = self.width - 2
        numHashes = (percentDone / 100.0) * allFull
        numHashes = int(round(numHashes))

        # Build progress bar
        output = "[" + '#'*numHashes + ' '*(allFull-numHashes) + "]"

        # Append percentage
        output += ' %3d%%' % percentDone

        # Calculate elapsed time
        mins = 0
        hours = 0
        if secs >= 60 * 60:
            hours = int(secs / (60 * 60))
            secs -= hours * (60 * 60)
        if secs >= 60:
            mins = int(secs / 60)
            secs -= mins * 60
        #output += ' %02d:%02d:%02d' % (hours,mins,secs) #hours, mins, secs)

        output += ' ' + self.note
        self.maxWidth = max(len(output), self.maxWidth)
        output += ' ' * (self.maxWidth - len(output))

        # Write to display
        sys.stdout.write('\r%s\r' % output)

        if 100 == percentDone:
            sys.stdout.write('\n')


class MinidumpStackwalkParser(object):
    '''
    Parses output of minidump_stackwalk
    '''
    def __init__(self):
        pass

    def _parse(self, dump):
        result = []
        try:
            # Note: following line only works on Unix
            fnull = open('/dev/null', 'w')
            output = subprocess.check_output(['minidump_stackwalk', dump], stderr=fnull)
            result = output.split('\n')
        except:
            pass
        return result

    def get_libs(self, dump):
        result = []
        output = self._parse(dump)
        in_section = False
        for line in output:
            if in_section:
                tokens = line.split()
                if len(tokens) > 3:
                    lib = tokens[3]
                    if lib.endswith('.so'):
                        result.append(Library(lib))
                else:
                    in_section = False
            if line.startswith('Loaded modules:'):
                in_section = True
        return result


class Library(object):
    '''
    Represents an .so file
    '''
    def __init__(self, name):
        self.name = name
        self.path = None
        self.sym_name = None
        self.sym_hash = None
        self.sym_path = None

    def __repr__(self):
        result = self.name
        if self.path:
            result += '(' + self.path + ')'
        return result


#------------------------------------------------------------------------------
# Utility functions
#------------------------------------------------------------------------------

def print_error(message):
    print >> sys.stderr, 'Error:', message


def parse_command_line():
    '''
    Return: argparse.Namespace
    '''
    parser = ArgumentParser()
    return parser.parse_args()


def print_summary(args, *initial_group):
    '''
    Print results of parsing command line
    Second argument indicates which values should be displayed at the top of
    the list.  These should typically be the destination variables for the
    positional parameters.
    '''
    keys = [name for name in dir(args) if not name.startswith('_')]
    maxkeylen = max([len(key) for key in keys])
    maxvaluelen = max([len(str(getattr(args, key))) for key in keys])
    rightcolpos = LINE_WIDTH - maxvaluelen - 2
    print '-' * LINE_WIDTH
    print 'Summary of options'
    print '-' * LINE_WIDTH
    for key in initial_group:
        print ' '+ key, ('.' * (rightcolpos - len(key) - 2)), getattr(args, key)
    for key in sorted(list(set(keys) - set(initial_group))):
        print ' '+ key, ('.' * (rightcolpos - len(key) - 2)), getattr(args, key)
    print '-' * LINE_WIDTH


def file_exists(filename):
    result = True
    try:
        with open(filename) as f: pass
    except IOError as e:
        result = False
    return result


def build_lib_dict(lib_dir, args):
    result = {}
    for root, dirs, files in os.walk(lib_dir):
        for name in files:
            if name.endswith('.so'):
                path = os.path.join(root, name)
                logging.debug('build_lib_dict ' + name + ' ' + path)
                result[name] = path
    return result


def resolve_libs(libs, args):
    lib_dir = os.path.join(os.environ['ANDROID_PRODUCT_OUT'], 'symbols')
    lib_dict = build_lib_dict(lib_dir, args)
    for lib in libs:
        if lib.name in lib_dict.keys():
            lib.path = lib_dict[lib.name]
        else:
            print >> sys.stderr,'Warning: failed to resolve ' + lib.name


def generate_symbols(lib, args):
    sym_dir = os.path.join(os.environ['ANDROID_PRODUCT_OUT'], 'symbols', 'minidump')
    logging.debug("generate_symbols so_path " + lib.path)
    # Note: following line only works on Unix
    fnull = open('/dev/null', 'w')
    output = subprocess.check_output(['dump_syms', lib.path], stderr=fnull)
    if output.startswith('MODULE'):
        lines = output.split('\n')
        tokens = lines[0].split()
        sym_name = tokens[4]
        logging.debug("generate_symbols sym_name " + sym_name)
        if sym_name == lib.name:
            lib.sym_name = sym_name
            lib.sym_hash = tokens[3]
            logging.debug("generate_symbols sym_hash " + lib.sym_hash)
            lib.sym_path = os.path.join(sym_dir, lib.sym_name, lib.sym_hash, lib.sym_name + '.sym')
            logging.debug("generate_symbols sym_path " + lib.sym_path)
            if not os.path.exists(lib.sym_path):
                os.makedirs(os.path.dirname(lib.sym_path))
                sym_file = open(lib.sym_path, 'w')
                sym_file.write(output)
        else:
            print >> sys.stderr,'Warning: symbol name mismatch ({0:s}, {1:s}'.format(lib.name, sym_name)


def generate_all_symbols(libs, args):
    print "\nGenerating symbols ..."
    p = ProgressBar(maxValue = len(libs))
    n = 0
    for lib in libs:
        p.update(note = lib.name)
        if lib.path:
            generate_symbols(lib, args)
        n += 1
        p.update(note = lib.name, amount = n)
    print


def print_libs(libs):
    print '----------------------------------------------------------------'
    print 'name                              resolved  symbols'
    print '----------------------------------------------------------------'
    for lib in libs:
        has_path = 'y' if lib.path else 'n'
        sym_hash = lib.sym_hash[0:6] if lib.sym_hash else '-'
        print '{0:40s} {1:s}   {2:s}'.format(lib.name, has_path, sym_hash)
    print '----------------------------------------------------------------'



#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

args = parse_command_line()

if args.verbose:
    print_summary(args, ('dump'))
if args.debug:
    logging.getLogger().setLevel(logging.DEBUG)

if os.environ['ANDROID_PRODUCT_OUT'] == '':
    raise IOError, "ANDROID_PRODUCT_OUT is not set - have you lunched?"

parser = MinidumpStackwalkParser()
libs = parser.get_libs(args.dump)

resolve_libs(libs, args)
generate_all_symbols(libs, args)
print_libs(libs)

# TODO: re-process dump file

#logging.debug('Testing testing 123')

