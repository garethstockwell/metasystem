#!/usr/bin/env python

# android-breakpad-decode

#------------------------------------------------------------------------------
# Imports
#------------------------------------------------------------------------------

import argparse
import logging
import os
import subprocess
import sys


#------------------------------------------------------------------------------
# Global constants
#------------------------------------------------------------------------------

LINE_WIDTH = 80


#------------------------------------------------------------------------------
# Classes
#------------------------------------------------------------------------------

class ArgumentParser(argparse.ArgumentParser):
    def __init__(self):
        description = 'Android BreakPad decoder'
        epilog = '''
        Script for decoding crash dumps generated by Android apps using the
        Google BreakPad tool
        '''
        version = '0.1'

        argparse.ArgumentParser.__init__(self,
                                         description = description,
                                         epilog = epilog)

        # Positional arguments
        self.add_argument('dump',
                          metavar='DUMP',
                          help='Dump file')

        # Options
        self.add_argument('--debug',
                          dest='debug', default=False,
                          action='store_true',
                          help='show debugging output')
        self.add_argument('-n', '--dry-run',
                          dest='dry_run', default=False,
                          action='store_true',
                          help='just show what would be done')
        self.add_argument('-v', '--verbose',
                          dest='verbose', default=False,
                          action='store_true',
                          help='produce verbose output')
        self.add_argument('-V', '--version',
                          dest='version',
                          action='version',
                          version=version,
                          help="show program's version number and exit")


class MinidumpStackwalkParser(object):
    '''
    Parses output of minidump_stackwalk
    '''
    def __init__(self):
        pass

    def _parse(self, dump):
        result = []
        try:
            # Note: following line only works on Unix
            fnull = open('/dev/null', 'w')
            output = subprocess.check_output(['minidump_stackwalk', dump], stderr=fnull)
            result = output.split('\n')
        except:
            pass
        return result

    def get_libs(self, dump):
        result = []
        output = self._parse(dump)
        in_section = False
        for line in output:
            if in_section:
                tokens = line.split()
                if len(tokens) > 3:
                    lib = tokens[3]
                    if lib.endswith('.so'):
                        result.append(Library(lib))
                else:
                    in_section = False
            if line.startswith('Loaded modules:'):
                in_section = True
        return result


class Library(object):
    '''
    Represents an .so file
    '''
    def __init__(self, name):
        self.name = name
        self.path = None
        self.sym_path = None

    def __repr__(self):
        result = self.name
        if self.path:
            result += '(' + self.path + ')'
        return result


#------------------------------------------------------------------------------
# Utility functions
#------------------------------------------------------------------------------

def print_error(message):
    print >> sys.stderr, 'Error:', message


def parse_command_line():
    '''
    Return: argparse.Namespace
    '''
    parser = ArgumentParser()
    return parser.parse_args()


def print_summary(args, *initial_group):
    '''
    Print results of parsing command line
    Second argument indicates which values should be displayed at the top of
    the list.  These should typically be the destination variables for the
    positional parameters.
    '''
    keys = [name for name in dir(args) if not name.startswith('_')]
    maxkeylen = max([len(key) for key in keys])
    maxvaluelen = max([len(str(getattr(args, key))) for key in keys])
    rightcolpos = LINE_WIDTH - maxvaluelen - 2
    print '-' * LINE_WIDTH
    print 'Summary of options'
    print '-' * LINE_WIDTH
    for key in initial_group:
        print ' '+ key, ('.' * (rightcolpos - len(key) - 2)), getattr(args, key)
    for key in sorted(list(set(keys) - set(initial_group))):
        print ' '+ key, ('.' * (rightcolpos - len(key) - 2)), getattr(args, key)
    print '-' * LINE_WIDTH


def file_exists(filename):
    result = True
    try:
        with open(filename) as f: pass
    except IOError as e:
        result = False
    return result


def resolve_libs(libs):
    lib_dir = os.path.join(os.environ['ANDROID_PRODUCT_OUT'], 'symbols', 'system', 'lib')
    for lib in libs:
        lib_path = os.path.join(lib_dir, lib.name)
        if file_exists(lib_path):
            lib.path = lib_path


def generate_symbols(libs):
    # TODO
    pass


def print_libs(libs):
    print '----------------------------------------------------------------'
    print 'name                              resolved  symbols'
    print '----------------------------------------------------------------'
    for lib in libs:
        has_path = 'y' if lib.path else 'n'
        has_sym = 'y' if lib.sym_path else 'n'
        print '{0:40s} {1:s}        {2:s}'.format(lib.name, has_path, has_sym)
    print '----------------------------------------------------------------'



#------------------------------------------------------------------------------
# Main
#------------------------------------------------------------------------------

args = parse_command_line()

if args.verbose:
    print_summary(args, ('dump'))
if args.debug:
    logging.getLogger().setLevel(logging.DEBUG)

if os.environ['ANDROID_PRODUCT_OUT'] == '':
    raise IOError, "ANDROID_PRODUCT_OUT is not set - have you lunched?"

parser = MinidumpStackwalkParser()
libs = parser.get_libs(args.dump)

resolve_libs(libs)
generate_symbols(libs)
print_libs(libs)

# TODO: re-process dump file

#logging.debug('Testing testing 123')

